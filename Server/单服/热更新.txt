热更新包括客户端热更新和服务器热更新。而热更新大部分逻辑都在服务器。

为什么要热更新：
这是因为游戏服务器的特点决定的。
因为游戏服务器是有状态的服务器（例如战斗），服务器不能随时重启，一旦重启，需要给玩家补偿。当服务器发现有错误的时候，需要立即修复错误，而在不重启服务器的前提下，更新服务器逻辑，即为热更新。

热更新的内容可以是服务器逻辑，服务器数据，客户端逻辑，客户端资源等，原则上在上线之前，就应该尽量提供所有的热更新能力。

服务端逻辑更新：
因为C++天生的具有内核态程序，所以游戏大部分都会采用脚本语言，通过在C++跑一层虚拟机（lua，python，js），使得整体服务器具有热更新能力。
更新逻辑一般需要达到两层能力：
第一层：新的对象将使用新的代码
第二层：旧的对象也要使用新的代码

常用的方式就是把原有代码的“函数指针”指向新的“函数指针”，使得当调用代码的时候，即可调用新的函数（对象）。
因此，在程序使用的时候，必然需要考虑的是，我保存的不能是函数地址、对象地址（例如lua的self），而是函数名字、对象名字。

热更的实现方式也分成两个层次。
第一个层次就是我需要写特殊的热更逻辑，该逻辑是标识我要热更哪个文件的哪个函数，把函数的进行替换（老方式）。框架简单，但是热更新逻辑复杂，对小游戏友好。
第二个层次就是我直接写新文件的逻辑，通过热更新框架把整个文件的逻辑进行替换，但是相对上一层次，更新的能力会弱一点（例如无法更新递归table）。框架复杂，但是热更新逻辑简单，比较适合大型游戏。


因为客户端在玩家手上，因此客户端热更新能力相对服务器而言，需要考虑的内容会有所区别。
客户端更新也是分成两层：
第一层实现方式是，只能在玩家在登录界面（或者固定界面）更新。严格来说，这种不算热更新，而只能算是半热更新。实现简单，实现的热更能力是最强。
第二层实现方式是，就是在玩家在任何状态下均可更新。实现相对复杂，但是逻辑更新能力相对较弱。

因为客户端掌握在玩家手上，所以需要服务端通知客户端去更新。因此也是需要考虑以下几种情况：
第一种就是普通的更新。即客户端在任何运行态，把逻辑更新了。一般只能更新代码逻辑和配置表。
第二种就是固定界面更新。需要服务器通知客户端回退到登录界面，或者等下次到登录界面的时候才会更新。这部分一般是需要更新资源这种情况。因为资源已经载入到内存（显存）中而无法进行更新。
第三种是包体本身更新。这种一般都是有严重问题才会使用，需要服务器强踢玩家下线等方式来让玩家进行更新。





