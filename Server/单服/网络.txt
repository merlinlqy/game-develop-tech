在游戏里面，客户端和服务端都会采取长链接方式。
因为客户端服务端将会反复互发消息。
采取的底层可以是TCP，也可以是UDP（UDP一般会做一层包装实现类似长链接的方式，例如KCP）。

再上层可以用WebSocket（少量）。

对于游戏网络层，需要以下基本功能：
客户端预定的服务器地址，连接服务器并且与服务器通讯。
而服务器将会不断地监听端口，从客户端的连接中互发消息。

因此，无论客户端和服务端，将会提供两个基本的网络接口：send，write
而客户端将会有一个connect接口，用以连接服务器
而服务器将会有一个listen接口，用以监听客户端

而服务器需要与多个客户端连接，所以还要区分每个客户端的唯一标识。例如Linux的FD，或者抽象成session id等。

客户端接口抽象：
connect(server_name/ip, port)
send(buffer)
write(buffer)
close()

服务器接口抽象：
listen(port)
send(fd, buffer)
write(fd, buffer)
close(fd)

上面是假设使用tcp的情况下的接口，UDP实现类似长链接功能可能需要考虑能力: 包的顺序，重传

在send和write之上，网络层还要考虑合包和解包问题

不管服务端还是客户端，一个send和write可能无法把包完整传输。
在计算机的网络层，buffer都需要固定最大长度，因此当数据包超过这个长度以后，则需要把包分拆。
即使能够长度足够，但也有可能因为os底层拥塞的原因，也会导致只能发送部分buffer，因此还是需要进行重传。
这里就存在合包和分包问题，多数采用ringbuffer以及加上发送包长度来进行具体处理。


在原始网络数据包之上，一般还会有一层schema的抽象层，也就是如何解释这些二进制码。
这部分各个项目不定，有些直接是一个opcode标识是哪个包，然后直接原始struct来进行封装。也有一些已有的数据包格式，例如skynet采取sproto，Google的proto buffer等。














